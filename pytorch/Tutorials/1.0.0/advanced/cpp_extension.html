
<!DOCTYPE html>

<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Custom C++ and CUDA Extensions — PyTorch Tutorials 1.0.0 documentation</title>
<link href="../_static/css/theme.css" rel="stylesheet" type="text/css"/>
<!-- <link rel="stylesheet" href="../_static/pygments.css" type="text/css" /> -->
<link href="../_static/gallery.css" rel="stylesheet" type="text/css"/>
<link href="../genindex.html" rel="index" title="Index"/>
<link href="../search.html" rel="search" title="Search"/>
<link href="torch_script_custom_ops.html" rel="next" title="Extending TorchScript with Custom C++ Operators"/>
<link href="numpy_extensions_tutorial.html" rel="prev" title="Creating Extensions Using numpy and scipy"/>
<script src="../_static/js/modernizr.min.js"></script>
</head>
<div class="container-fluid header-holder tutorials-header" id="header-holder">
<div class="container">
<div class="header-container">
<a aria-label="PyTorch" class="header-logo" href="https://pytorch.org/"></a>
<div class="main-menu">
<ul>
<li>
<a href="https://pytorch.org/get-started">Get Started</a>
</li>
<li>
<a href="https://pytorch.org/features">Features</a>
</li>
<li>
<a href="https://pytorch.org/ecosystem">Ecosystem</a>
</li>
<li>
<a href="https://pytorch.org/blog/">Blog</a>
</li>
<li class="active">
<a href="https://pytorch.org/tutorials">Tutorials</a>
</li>
<li>
<a href="https://pytorch.org/docs/stable/index.html">Docs</a>
</li>
<li>
<a href="https://pytorch.org/resources">Resources</a>
</li>
<li>
<a href="https://github.com/pytorch/pytorch">Github</a>
</li>
</ul>
</div>
<a class="main-menu-open-button" data-behavior="open-mobile-menu" href="#"></a>
</div>
</div>
</div>
<body class="pytorch-body">
<div class="table-of-contents-link-wrapper">
<span>Table of Contents</span>
<a class="toggle-table-of-contents" data-behavior="toggle-table-of-contents" href="#"></a>
</div>
<nav class="pytorch-left-menu" data-toggle="wy-nav-shift" id="pytorch-left-menu">
<div class="pytorch-side-scroll">
<div aria-label="main navigation" class="pytorch-menu pytorch-menu-vertical" data-spy="affix" role="navigation">
<div class="pytorch-left-menu-search">
<div class="version">
                  1.0.0
                </div>
<div role="search">
<form action="../search.html" class="wy-form" id="rtd-search-form" method="get">
<input name="q" placeholder="Search Tutorials" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../beginner/deep_learning_60min_blitz.html">Deep Learning with PyTorch: A 60 Minute Blitz</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/data_loading_tutorial.html">Data Loading and Processing Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/pytorch_with_examples.html">Learning PyTorch with Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/transfer_learning_tutorial.html">Transfer Learning Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/deploy_seq2seq_hybrid_frontend_tutorial.html">Deploying a Seq2Seq Model with the Hybrid Frontend</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/saving_loading_models.html">Saving and Loading Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/nn_tutorial.html">What is <cite>torch.nn</cite> <em>really</em>?</a></li>
</ul>
<p class="caption"><span class="caption-text">Image</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/torchvision_tutorial.html">TorchVision 0.3 Object Detection Finetuning Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/finetuning_torchvision_models_tutorial.html">Finetuning Torchvision Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/spatial_transformer_tutorial.html">Spatial Transformer Networks Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="neural_style_tutorial.html">Neural Transfer Using PyTorch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/fgsm_tutorial.html">Adversarial Example Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="super_resolution_with_caffe2.html">Transfering a Model from PyTorch to Caffe2 and Mobile using ONNX</a></li>
</ul>
<p class="caption"><span class="caption-text">Text</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../beginner/chatbot_tutorial.html">Chatbot Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/char_rnn_generation_tutorial.html">Generating Names with a Character-Level RNN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/char_rnn_classification_tutorial.html">Classifying Names with a Character-Level RNN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/deep_learning_nlp_tutorial.html">Deep Learning for NLP with Pytorch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/seq2seq_translation_tutorial.html">Translation with a Sequence to Sequence Network and Attention</a></li>
</ul>
<p class="caption"><span class="caption-text">Generative</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../beginner/dcgan_faces_tutorial.html">DCGAN Tutorial</a></li>
</ul>
<p class="caption"><span class="caption-text">Reinforcement Learning</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/reinforcement_q_learning.html">Reinforcement Learning (DQN) Tutorial</a></li>
</ul>
<p class="caption"><span class="caption-text">Extending PyTorch</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="numpy_extensions_tutorial.html">Creating Extensions Using numpy and scipy</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Custom C++ and CUDA Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="torch_script_custom_ops.html">Extending TorchScript with Custom C++ Operators</a></li>
</ul>
<p class="caption"><span class="caption-text">Production Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/model_parallel_tutorial.html">Model Parallel Best Practices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/ddp_tutorial.html">Getting Started with Distributed Data Parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/dist_tuto.html">Writing Distributed Applications with PyTorch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/aws_distributed_training_tutorial.html">PyTorch 1.0 Distributed Trainer with Amazon AWS</a></li>
<li class="toctree-l1"><a class="reference internal" href="ONNXLive.html">ONNX Live Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="cpp_export.html">Loading a PyTorch Model in C++</a></li>
</ul>
<p class="caption"><span class="caption-text">PyTorch in Other Languages</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="cpp_frontend.html">Using the PyTorch C++ Frontend</a></li>
</ul>
</div>
</div>
</nav>
<div class="pytorch-container">
<div class="pytorch-page-level-bar" id="pytorch-page-level-bar">
<div class="pytorch-breadcrumbs-wrapper">
<div aria-label="breadcrumbs navigation" role="navigation">
<ul class="pytorch-breadcrumbs">
<li>
<a href="../index.html">
          
            Tutorials
          
        </a> &gt;
      </li>
<li>Custom C++ and CUDA Extensions</li>
<li class="pytorch-breadcrumbs-aside">
<a href="../_sources/advanced/cpp_extension.rst.txt" rel="nofollow"><img src="../_static/images/view-page-source-icon.svg"/></a>
</li>
</ul>
</div>
</div>
<div class="pytorch-shortcuts-wrapper" id="pytorch-shortcuts-wrapper">
          Shortcuts
        </div>
</div>
<section class="pytorch-content-wrap" data-toggle="wy-nav-shift" id="pytorch-content-wrap">
<div class="pytorch-content-left">
<div class="rst-content">
<div class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<article class="pytorch-article" id="pytorch-article" itemprop="articleBody">
<div class="section" id="custom-c-and-cuda-extensions">
<h1>Custom C++ and CUDA Extensions<a class="headerlink" href="#custom-c-and-cuda-extensions" title="Permalink to this headline">¶</a></h1>
<p><strong>Author</strong>: <a class="reference external" href="https://www.goldsborough.me/">Peter Goldsborough</a></p>
<p>PyTorch provides a plethora of operations related to neural networks, arbitrary
tensor algebra, data wrangling and other purposes. However, you may still find
yourself in need of a more customized operation. For example, you might want to
use a novel activation function you found in a paper, or implement an operation
you developed as part of your research.</p>
<p>The easiest way of integrating such a custom operation in PyTorch is to write it
in Python by extending <code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code> as outlined <a class="reference external" href="https://pytorch.org/docs/master/notes/extending.html">here</a>. This gives you the full
power of automatic differentiation (spares you from writing derivative
functions) as well as the usual expressiveness of Python. However, there may be
times when your operation is better implemented in C++. For example, your code
may need to be <em>really</em> fast because it is called very frequently in your model
or is very expensive even for few calls. Another plausible reason is that it
depends on or interacts with other C or C++ libraries. To address such cases,
PyTorch provides a very easy way of writing custom <em>C++ extensions</em>.</p>
<p>C++ extensions are a mechanism we have developed to allow users (you) to create
PyTorch operators defined <em>out-of-source</em>, i.e. separate from the PyTorch
backend. This approach is <em>different</em> from the way native PyTorch operations are
implemented. C++ extensions are intended to spare you much of the boilerplate
associated with integrating an operation with PyTorch’s backend while providing
you with a high degree of flexibility for your PyTorch-based projects.
Nevertheless, once you have defined your operation as a C++ extension, turning
it into a native PyTorch function is largely a matter of code organization,
which you can tackle after the fact if you decide to contribute your operation
upstream.</p>
<div class="section" id="motivation-and-example">
<h2>Motivation and Example<a class="headerlink" href="#motivation-and-example" title="Permalink to this headline">¶</a></h2>
<p>The rest of this note will walk through a practical example of writing and using
a C++ (and CUDA) extension. If you are being chased or someone will fire you if
you don’t get that op done by the end of the day, you can skip this section and
head straight to the implementation details in the next section.</p>
<p>Let’s say you’ve come up with a new kind of recurrent unit that you found to
have superior properties compared to the state of the art. This recurrent unit
is similar to an LSTM, but differs in that it lacks a <em>forget gate</em> and uses an
<em>Exponential Linear Unit</em> (ELU) as its internal activation function. Because
this unit never forgets, we’ll call it <em>LLTM</em>, or <em>Long-Long-Term-Memory</em> unit.</p>
<p>The two ways in which LLTMs differ from vanilla LSTMs are significant enough
that we can’t configure PyTorch’s <code class="docutils literal notranslate"><span class="pre">LSTMCell</span></code> for our purposes, so we’ll have to
create a custom cell. The first and easiest approach for this – and likely in
all cases a good first step – is to implement our desired functionality in
plain PyTorch with Python. For this, we need to subclass
<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.Module</span></code> and implement the forward pass of the LLTM. This would
look something like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LLTM</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_features</span><span class="p">,</span> <span class="n">state_size</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LLTM</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_features</span> <span class="o">=</span> <span class="n">input_features</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span> <span class="o">=</span> <span class="n">state_size</span>
        <span class="c1"># 3 * state_size for input gate, output gate and candidate cell gate.</span>
        <span class="c1"># input_features + state_size because we will multiply with [input, h].</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">state_size</span><span class="p">,</span> <span class="n">input_features</span> <span class="o">+</span> <span class="n">state_size</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bias</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">state_size</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_parameters</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">stdv</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">weight</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">():</span>
            <span class="n">weight</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">uniform_</span><span class="p">(</span><span class="o">-</span><span class="n">stdv</span><span class="p">,</span> <span class="o">+</span><span class="n">stdv</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">old_h</span><span class="p">,</span> <span class="n">old_cell</span> <span class="o">=</span> <span class="n">state</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">old_h</span><span class="p">,</span> <span class="nb">input</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Compute the input, output and candidate cell gates with one MM.</span>
        <span class="n">gate_weights</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span><span class="p">)</span>
        <span class="c1"># Split the combined gate weight matrix into its components.</span>
        <span class="n">gates</span> <span class="o">=</span> <span class="n">gate_weights</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">input_gate</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">output_gate</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Here we use an ELU instead of the usual tanh.</span>
        <span class="n">candidate_cell</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">elu</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># Compute the new cell state.</span>
        <span class="n">new_cell</span> <span class="o">=</span> <span class="n">old_cell</span> <span class="o">+</span> <span class="n">candidate_cell</span> <span class="o">*</span> <span class="n">input_gate</span>
        <span class="c1"># Compute the new hidden state and output.</span>
        <span class="n">new_h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">new_cell</span><span class="p">)</span> <span class="o">*</span> <span class="n">output_gate</span>

        <span class="k">return</span> <span class="n">new_h</span><span class="p">,</span> <span class="n">new_cell</span>
</pre></div>
</div>
<p>which we could then use as expected:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">input_features</span><span class="p">)</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">state_size</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">state_size</span><span class="p">)</span>

<span class="n">rnn</span> <span class="o">=</span> <span class="n">LLTM</span><span class="p">(</span><span class="n">input_features</span><span class="p">,</span> <span class="n">state_size</span><span class="p">)</span>

<span class="n">new_h</span><span class="p">,</span> <span class="n">new_C</span> <span class="o">=</span> <span class="n">rnn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
</pre></div>
</div>
<p>Naturally, if at all possible and plausible, you should use this approach to
extend PyTorch. Since PyTorch has highly optimized implementations of its
operations for CPU <em>and</em> GPU, powered by libraries such as <a class="reference external" href="https://developer.nvidia.com/cudnn">NVIDIA cuDNN</a>, <a class="reference external" href="https://software.intel.com/en-us/mkl">Intel MKL</a> or <a class="reference external" href="https://github.com/Maratyszcza/NNPACK">NNPACK</a>, PyTorch code like above will often be
fast enough. However, we can also see why, under certain circumstances, there is
room for further performance improvements. The most obvious reason is that
PyTorch has no knowledge of the <em>algorithm</em> you are implementing. It knows only
of the individual operations you use to compose your algorithm. As such, PyTorch
must execute your operations individually, one after the other. Since each
individual call to the implementation (or <em>kernel</em>) of an operation, which may
involve launch of a CUDA kernel, has a certain amount of overhead, this overhead
may become significant across many function calls. Furthermore, the Python
interpreter that is running our code can itself slow down our program.</p>
<p>A definite method of speeding things up is therefore to rewrite parts in C++ (or
CUDA) and <em>fuse</em> particular groups of operations. Fusing means combining the
implementations of many functions into a single functions, which profits from
fewer kernel launches as well as other optimizations we can perform with
increased visibility of the global flow of data.</p>
<p>Let’s see how we can use C++ extensions to implement a <em>fused</em> version of the
LLTM. We’ll begin by writing it in plain C++, using the <a class="reference external" href="https://github.com/zdevito/ATen">ATen</a> library that powers much of PyTorch’s
backend, and see how easily it lets us translate our Python code. We’ll then
speed things up even more by moving parts of the model to CUDA kernel to benefit
from the massive parallelism GPUs provide.</p>
</div>
<div class="section" id="writing-a-c-extension">
<h2>Writing a C++ Extension<a class="headerlink" href="#writing-a-c-extension" title="Permalink to this headline">¶</a></h2>
<p>C++ extensions come in two flavors: They can be built “ahead of time” with
<code class="xref py py-mod docutils literal notranslate"><span class="pre">setuptools</span></code>, or “just in time” via
<code class="xref py py-func docutils literal notranslate"><span class="pre">torch.utils.cpp_extension.load()</span></code>. We’ll begin with the first approach and
discuss the latter later.</p>
<div class="section" id="building-with-setuptools">
<h3>Building with <code class="xref py py-mod docutils literal notranslate"><span class="pre">setuptools</span></code><a class="headerlink" href="#building-with-setuptools" title="Permalink to this headline">¶</a></h3>
<p>For the “ahead of time” flavor, we build our C++ extension by writing a
<code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script that uses setuptools to compile our C++ code. For the LLTM, it
looks as simple as this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="k">import</span> <span class="n">setup</span>
<span class="kn">from</span> <span class="nn">torch.utils.cpp_extension</span> <span class="k">import</span> <span class="n">CppExtension</span><span class="p">,</span> <span class="n">BuildExtension</span>

<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">'lltm_cpp'</span><span class="p">,</span>
      <span class="n">ext_modules</span><span class="o">=</span><span class="p">[</span><span class="n">CppExtension</span><span class="p">(</span><span class="s1">'lltm'</span><span class="p">,</span> <span class="p">[</span><span class="s1">'lltm.cpp'</span><span class="p">])],</span>
      <span class="n">cmdclass</span><span class="o">=</span><span class="p">{</span><span class="s1">'build_ext'</span><span class="p">:</span> <span class="n">BuildExtension</span><span class="p">})</span>
</pre></div>
</div>
<p>In this code, <code class="xref py py-class docutils literal notranslate"><span class="pre">CppExtension</span></code> is a convenience wrapper around
<code class="xref py py-class docutils literal notranslate"><span class="pre">setuptools.Extension</span></code> that passes the correct include paths and sets
the language of the extension to C++. The equivalent vanilla <code class="xref py py-mod docutils literal notranslate"><span class="pre">setuptools</span></code>
code would simply be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">setuptools</span><span class="o">.</span><span class="n">Extension</span><span class="p">(</span>
   <span class="n">name</span><span class="o">=</span><span class="s1">'lltm_cpp'</span><span class="p">,</span>
   <span class="n">sources</span><span class="o">=</span><span class="p">[</span><span class="s1">'lltm.cpp'</span><span class="p">],</span>
   <span class="n">include_dirs</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">cpp_extension</span><span class="o">.</span><span class="n">include_paths</span><span class="p">(),</span>
   <span class="n">language</span><span class="o">=</span><span class="s1">'c++'</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">BuildExtension</span></code> performs a number of required configuration steps and
checks and also manages mixed compilation in the case of mixed C++/CUDA
extensions. And that’s all we really need to know about building C++ extensions
for now! Let’s now take a look at the implementation of our C++ extension,
which goes into <code class="docutils literal notranslate"><span class="pre">lltm.cpp</span></code>.</p>
</div>
<div class="section" id="writing-the-c-op">
<h3>Writing the C++ Op<a class="headerlink" href="#writing-the-c-op" title="Permalink to this headline">¶</a></h3>
<p>Let’s start implementing the LLTM in C++! One function we’ll need for the
backward pass is the derivative of the sigmoid. This is a small enough piece of
code to discuss the overall environment that is available to us when writing C++
extensions:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;torch/extension.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">d_sigmoid</span><span class="p">(</span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&lt;torch/extension.h&gt;</span></code> is the one-stop header to include all the necessary PyTorch
bits to write C++ extensions. It includes:</p>
<ul class="simple">
<li>The ATen library, which is our primary API for tensor computation,</li>
<li><a class="reference external" href="https://github.com/pybind/pybind11">pybind11</a>, which is how we create Python bindings for our C++ code,</li>
<li>Headers that manage the details of interaction between ATen and pybind11.</li>
</ul>
<p>The implementation of <code class="xref py py-func docutils literal notranslate"><span class="pre">d_sigmoid()</span></code> shows how to use the ATen API.
PyTorch’s tensor and variable interface is generated automatically from the
ATen library, so we can more or less translate our Python implementation 1:1
into C++. Our primary datatype for all computations will be
<code class="xref py py-class docutils literal notranslate"><span class="pre">torch::Tensor</span></code>. Its full API can be inspected <a class="reference external" href="https://pytorch.org/cppdocs/api/classat_1_1_tensor.html">here</a>. Notice
also that we can include <code class="docutils literal notranslate"><span class="pre">&lt;iostream&gt;</span></code> or <em>any other C or C++ header</em> – we have
the full power of C++11 at our disposal.</p>
<div class="section" id="forward-pass">
<h4>Forward Pass<a class="headerlink" href="#forward-pass" title="Permalink to this headline">¶</a></h4>
<p>Next we can port our entire forward pass to C++:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lltm_forward</span><span class="p">(</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">input</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">weights</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">bias</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">old_h</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">old_cell</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">cat</span><span class="p">({</span><span class="n">old_h</span><span class="p">,</span> <span class="n">input</span><span class="p">},</span> <span class="cm">/*dim=*/</span><span class="mi">1</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">gate_weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">addmm</span><span class="p">(</span><span class="n">bias</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">weights</span><span class="p">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
  <span class="k">auto</span> <span class="n">gates</span> <span class="o">=</span> <span class="n">gate_weights</span><span class="p">.</span><span class="n">chunk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="cm">/*dim=*/</span><span class="mi">1</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">input_gate</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="k">auto</span> <span class="n">output_gate</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="k">auto</span> <span class="n">candidate_cell</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">elu</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="cm">/*alpha=*/</span><span class="mf">1.0</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">new_cell</span> <span class="o">=</span> <span class="n">old_cell</span> <span class="o">+</span> <span class="n">candidate_cell</span> <span class="o">*</span> <span class="n">input_gate</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">new_h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">tanh</span><span class="p">(</span><span class="n">new_cell</span><span class="p">)</span> <span class="o">*</span> <span class="n">output_gate</span><span class="p">;</span>

  <span class="k">return</span> <span class="p">{</span><span class="n">new_h</span><span class="p">,</span>
          <span class="n">new_cell</span><span class="p">,</span>
          <span class="n">input_gate</span><span class="p">,</span>
          <span class="n">output_gate</span><span class="p">,</span>
          <span class="n">candidate_cell</span><span class="p">,</span>
          <span class="n">X</span><span class="p">,</span>
          <span class="n">gate_weights</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="backward-pass">
<h4>Backward Pass<a class="headerlink" href="#backward-pass" title="Permalink to this headline">¶</a></h4>
<p>The C++ extension API currently does not provide a way of automatically
generating a backwards function for us. As such, we have to also implement the
backward pass of our LLTM, which computes the derivative of the loss with
respect to each input of the forward pass. Ultimately, we will plop both the
forward and backward function into a <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.autograd.Function</span></code> to create
a nice Python binding. The backward function is slightly more involved, so
we’ll not dig deeper into the code (if you are interested, <a class="reference external" href="https://www.cs.toronto.edu/~graves/phd.pdf">Alex Graves’ thesis</a> is a good read for more
information on this):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// tanh'(z) = 1 - tanh^2(z)</span>
<span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">d_tanh</span><span class="p">(</span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">z</span><span class="p">.</span><span class="n">tanh</span><span class="p">().</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// elu'(z) = relu'(z) + { alpha * exp(z) if (alpha * (exp(z) - 1)) &lt; 0, else 0}</span>
<span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">d_elu</span><span class="p">(</span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">z</span><span class="p">,</span> <span class="n">torch</span><span class="o">::</span><span class="n">Scalar</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="n">z</span><span class="p">.</span><span class="n">exp</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">z</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">).</span><span class="n">type_as</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">mask</span><span class="p">.</span><span class="n">type_as</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">e</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lltm_backward</span><span class="p">(</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">grad_h</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">grad_cell</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">new_cell</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">input_gate</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">output_gate</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">candidate_cell</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">X</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">gate_weights</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">weights</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">d_output_gate</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">tanh</span><span class="p">(</span><span class="n">new_cell</span><span class="p">)</span> <span class="o">*</span> <span class="n">grad_h</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">d_tanh_new_cell</span> <span class="o">=</span> <span class="n">output_gate</span> <span class="o">*</span> <span class="n">grad_h</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">d_new_cell</span> <span class="o">=</span> <span class="n">d_tanh</span><span class="p">(</span><span class="n">new_cell</span><span class="p">)</span> <span class="o">*</span> <span class="n">d_tanh_new_cell</span> <span class="o">+</span> <span class="n">grad_cell</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">d_old_cell</span> <span class="o">=</span> <span class="n">d_new_cell</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">d_candidate_cell</span> <span class="o">=</span> <span class="n">input_gate</span> <span class="o">*</span> <span class="n">d_new_cell</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">d_input_gate</span> <span class="o">=</span> <span class="n">candidate_cell</span> <span class="o">*</span> <span class="n">d_new_cell</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">gates</span> <span class="o">=</span> <span class="n">gate_weights</span><span class="p">.</span><span class="n">chunk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="cm">/*dim=*/</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">d_input_gate</span> <span class="o">*=</span> <span class="n">d_sigmoid</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">d_output_gate</span> <span class="o">*=</span> <span class="n">d_sigmoid</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">d_candidate_cell</span> <span class="o">*=</span> <span class="n">d_elu</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

  <span class="k">auto</span> <span class="n">d_gates</span> <span class="o">=</span>
      <span class="n">torch</span><span class="o">::</span><span class="n">cat</span><span class="p">({</span><span class="n">d_input_gate</span><span class="p">,</span> <span class="n">d_output_gate</span><span class="p">,</span> <span class="n">d_candidate_cell</span><span class="p">},</span> <span class="cm">/*dim=*/</span><span class="mi">1</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">d_weights</span> <span class="o">=</span> <span class="n">d_gates</span><span class="p">.</span><span class="n">t</span><span class="p">().</span><span class="n">mm</span><span class="p">(</span><span class="n">X</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">d_bias</span> <span class="o">=</span> <span class="n">d_gates</span><span class="p">.</span><span class="n">sum</span><span class="p">(</span><span class="cm">/*dim=*/</span><span class="mi">0</span><span class="p">,</span> <span class="cm">/*keepdim=*/</span><span class="nb">true</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">d_X</span> <span class="o">=</span> <span class="n">d_gates</span><span class="p">.</span><span class="n">mm</span><span class="p">(</span><span class="n">weights</span><span class="p">);</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">state_size</span> <span class="o">=</span> <span class="n">grad_h</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">d_old_h</span> <span class="o">=</span> <span class="n">d_X</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="cm">/*dim=*/</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">state_size</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">d_input</span> <span class="o">=</span> <span class="n">d_X</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="cm">/*dim=*/</span><span class="mi">1</span><span class="p">,</span> <span class="n">state_size</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">{</span><span class="n">d_old_h</span><span class="p">,</span> <span class="n">d_input</span><span class="p">,</span> <span class="n">d_weights</span><span class="p">,</span> <span class="n">d_bias</span><span class="p">,</span> <span class="n">d_old_cell</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="binding-to-python">
<h3>Binding to Python<a class="headerlink" href="#binding-to-python" title="Permalink to this headline">¶</a></h3>
<p>Once you have your operation written in C++ and ATen, you can use pybind11 to
bind your C++ functions or classes into Python in a very simple manner.
Questions or issues you have about this part of PyTorch C++ extensions will
largely be addressed by <a class="reference external" href="https://pybind11.readthedocs.io/en/master/">pybind11 documentation</a>.</p>
<p>For our extensions, the necessary binding code spans only four lines:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">PYBIND11_MODULE</span><span class="p">(</span><span class="n">TORCH_EXTENSION_NAME</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">"forward"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lltm_forward</span><span class="p">,</span> <span class="s">"LLTM forward"</span><span class="p">);</span>
  <span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">"backward"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lltm_backward</span><span class="p">,</span> <span class="s">"LLTM backward"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>One bit to note here is the macro <code class="docutils literal notranslate"><span class="pre">TORCH_EXTENSION_NAME</span></code>. The torch extension
build will define it as the name you give your extension in the <code class="docutils literal notranslate"><span class="pre">setup.py</span></code>
script. In this case, the value of <code class="docutils literal notranslate"><span class="pre">TORCH_EXTENSION_NAME</span></code> would be “lltm”.
This is to avoid having to maintain the name of the extension in two places
(the build script and your C++ code), as a mismatch between the two can lead to
nasty and hard to track issues.</p>
</div>
<div class="section" id="using-your-extension">
<h3>Using Your Extension<a class="headerlink" href="#using-your-extension" title="Permalink to this headline">¶</a></h3>
<p>We are now set to import our extension in PyTorch. At this point, your directory
structure could look something like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pytorch</span><span class="o">/</span>
  <span class="n">lltm</span><span class="o">-</span><span class="n">extension</span><span class="o">/</span>
    <span class="n">lltm</span><span class="o">.</span><span class="n">cpp</span>
    <span class="n">setup</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>Now, run <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">install</span></code> to build and install your extension. This
should look something like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>running install
running bdist_egg
running egg_info
creating lltm_cpp.egg-info
writing lltm_cpp.egg-info/PKG-INFO
writing dependency_links to lltm_cpp.egg-info/dependency_links.txt
writing top-level names to lltm_cpp.egg-info/top_level.txt
writing manifest file 'lltm_cpp.egg-info/SOURCES.txt'
reading manifest file 'lltm_cpp.egg-info/SOURCES.txt'
writing manifest file 'lltm_cpp.egg-info/SOURCES.txt'
installing library code to build/bdist.linux-x86_64/egg
running install_lib
running build_ext
building 'lltm_cpp' extension
creating build
creating build/temp.linux-x86_64-3.7
gcc -pthread -B ~/local/miniconda/compiler_compat -Wl,--sysroot=/ -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I~/local/miniconda/lib/python3.7/site-packages/torch/include -I~/local/miniconda/lib/python3.7/site-packages/torch/include/torch/csrc/api/include -I~/local/miniconda/lib/python3.7/site-packages/torch/include/TH -I~/local/miniconda/lib/python3.7/site-packages/torch/include/THC -I~/local/miniconda/include/python3.7m -c lltm.cpp -o build/temp.linux-x86_64-3.7/lltm.o -DTORCH_API_INCLUDE_EXTENSION_H -DTORCH_EXTENSION_NAME=lltm_cpp -D_GLIBCXX_USE_CXX11_ABI=1 -std=c++11
cc1plus: warning: command line option ‘-Wstrict-prototypes’ is valid for C/ObjC but not for C++
creating build/lib.linux-x86_64-3.7
g++ -pthread -shared -B ~/local/miniconda/compiler_compat -L~/local/miniconda/lib -Wl,-rpath=~/local/miniconda/lib -Wl,--no-as-needed -Wl,--sysroot=/ build/temp.linux-x86_64-3.7/lltm.o -o build/lib.linux-x86_64-3.7/lltm_cpp.cpython-37m-x86_64-linux-gnu.so
creating build/bdist.linux-x86_64
creating build/bdist.linux-x86_64/egg
copying build/lib.linux-x86_64-3.7/lltm_cpp.cpython-37m-x86_64-linux-gnu.so -&gt; build/bdist.linux-x86_64/egg
creating stub loader for lltm_cpp.cpython-37m-x86_64-linux-gnu.so
byte-compiling build/bdist.linux-x86_64/egg/lltm_cpp.py to lltm_cpp.cpython-37.pyc
creating build/bdist.linux-x86_64/egg/EGG-INFO
copying lltm_cpp.egg-info/PKG-INFO -&gt; build/bdist.linux-x86_64/egg/EGG-INFO
copying lltm_cpp.egg-info/SOURCES.txt -&gt; build/bdist.linux-x86_64/egg/EGG-INFO
copying lltm_cpp.egg-info/dependency_links.txt -&gt; build/bdist.linux-x86_64/egg/EGG-INFO
copying lltm_cpp.egg-info/top_level.txt -&gt; build/bdist.linux-x86_64/egg/EGG-INFO
writing build/bdist.linux-x86_64/egg/EGG-INFO/native_libs.txt
zip_safe flag not set; analyzing archive contents...
__pycache__.lltm_cpp.cpython-37: module references __file__
creating 'dist/lltm_cpp-0.0.0-py3.7-linux-x86_64.egg' and adding 'build/bdist.linux-x86_64/egg' to it
removing 'build/bdist.linux-x86_64/egg' (and everything under it)
Processing lltm_cpp-0.0.0-py3.7-linux-x86_64.egg
removing '~/local/miniconda/lib/python3.7/site-packages/lltm_cpp-0.0.0-py3.7-linux-x86_64.egg' (and everything under it)
creating ~/local/miniconda/lib/python3.7/site-packages/lltm_cpp-0.0.0-py3.7-linux-x86_64.egg
Extracting lltm_cpp-0.0.0-py3.7-linux-x86_64.egg to ~/local/miniconda/lib/python3.7/site-packages
lltm-cpp 0.0.0 is already the active version in easy-install.pth

Installed ~/local/miniconda/lib/python3.7/site-packages/lltm_cpp-0.0.0-py3.7-linux-x86_64.egg
Processing dependencies for lltm-cpp==0.0.0
Finished processing dependencies for lltm-cpp==0.0.0
</pre></div>
</div>
<p>A small note on compilers: Due to ABI versioning issues, the compiler you use to
build your C++ extension must be <em>ABI-compatible</em> with the compiler PyTorch was
built with. In practice, this means that you must use GCC version 4.9 and above on Linux.
For Ubuntu 16.04 and other more-recent Linux distributions, this should be the
default compiler already. On MacOS, you must use clang (which does not have any ABI versioning issues). In the worst
case, you can build PyTorch from source with your compiler and then build the
extension with that same compiler.</p>
<p>Once your extension is built, you can simply import it in Python, using the
name you specified in your <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script. Just be sure to <code class="docutils literal notranslate"><span class="pre">import</span>
<span class="pre">torch</span></code> first, as this will resolve some symbols that the dynamic linker must
see:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="kn">import</span> <span class="nn">torch</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="kn">import</span> <span class="nn">lltm_cpp</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="n">lltm_cpp</span><span class="o">.</span><span class="n">forward</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">lltm</span><span class="o">.</span><span class="n">PyCapsule</span><span class="o">.</span><span class="n">forward</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>If we call <code class="docutils literal notranslate"><span class="pre">help()</span></code> on the function or module, we can see that its signature
matches our C++ code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="n">help</span><span class="p">(</span><span class="n">lltm</span><span class="o">.</span><span class="n">forward</span><span class="p">)</span>
<span class="n">forward</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
    <span class="n">forward</span><span class="p">(</span><span class="n">arg0</span><span class="p">:</span> <span class="n">torch</span><span class="p">::</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">arg1</span><span class="p">:</span> <span class="n">torch</span><span class="p">::</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">arg2</span><span class="p">:</span> <span class="n">torch</span><span class="p">::</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">arg3</span><span class="p">:</span> <span class="n">torch</span><span class="p">::</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">arg4</span><span class="p">:</span> <span class="n">torch</span><span class="p">::</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">torch</span><span class="p">::</span><span class="n">Tensor</span><span class="p">]</span>

    <span class="n">LLTM</span> <span class="n">forward</span>
</pre></div>
</div>
<p>Since we are now able to call our C++ functions from Python, we can wrap them
with <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.autograd.Function</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.Module</span></code> to make them first
class citizens of PyTorch:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">torch</span>

<span class="c1"># Our module!</span>
<span class="kn">import</span> <span class="nn">lltm_cpp</span>

<span class="k">class</span> <span class="nc">LLTMFunction</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">old_h</span><span class="p">,</span> <span class="n">old_cell</span><span class="p">):</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">lltm_cpp</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">old_h</span><span class="p">,</span> <span class="n">old_cell</span><span class="p">)</span>
        <span class="n">new_h</span><span class="p">,</span> <span class="n">new_cell</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="n">weights</span><span class="p">]</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">save_for_backward</span><span class="p">(</span><span class="o">*</span><span class="n">variables</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_h</span><span class="p">,</span> <span class="n">new_cell</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">backward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">grad_h</span><span class="p">,</span> <span class="n">grad_cell</span><span class="p">):</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">lltm_cpp</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span>
            <span class="n">grad_h</span><span class="o">.</span><span class="n">contiguous</span><span class="p">(),</span> <span class="n">grad_cell</span><span class="o">.</span><span class="n">contiguous</span><span class="p">(),</span> <span class="o">*</span><span class="n">ctx</span><span class="o">.</span><span class="n">saved_variables</span><span class="p">)</span>
        <span class="n">d_old_h</span><span class="p">,</span> <span class="n">d_input</span><span class="p">,</span> <span class="n">d_weights</span><span class="p">,</span> <span class="n">d_bias</span><span class="p">,</span> <span class="n">d_old_cell</span> <span class="o">=</span> <span class="n">outputs</span>
        <span class="k">return</span> <span class="n">d_input</span><span class="p">,</span> <span class="n">d_weights</span><span class="p">,</span> <span class="n">d_bias</span><span class="p">,</span> <span class="n">d_old_h</span><span class="p">,</span> <span class="n">d_old_cell</span>


<span class="k">class</span> <span class="nc">LLTM</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_features</span><span class="p">,</span> <span class="n">state_size</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LLTM</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_features</span> <span class="o">=</span> <span class="n">input_features</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span> <span class="o">=</span> <span class="n">state_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">state_size</span><span class="p">,</span> <span class="n">input_features</span> <span class="o">+</span> <span class="n">state_size</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bias</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">state_size</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_parameters</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">stdv</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">weight</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">():</span>
            <span class="n">weight</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">uniform_</span><span class="p">(</span><span class="o">-</span><span class="n">stdv</span><span class="p">,</span> <span class="o">+</span><span class="n">stdv</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LLTMFunction</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span><span class="p">,</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="performance-comparison">
<h4>Performance Comparison<a class="headerlink" href="#performance-comparison" title="Permalink to this headline">¶</a></h4>
<p>Now that we are able to use and call our C++ code from PyTorch, we can run a
small benchmark to see how much performance we gained from rewriting our op in
C++. We’ll run the LLTM forwards and backwards a few times and measure the
duration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>

<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">input_features</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">state_size</span> <span class="o">=</span> <span class="mi">128</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">input_features</span><span class="p">)</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">state_size</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">state_size</span><span class="p">)</span>

<span class="n">rnn</span> <span class="o">=</span> <span class="n">LLTM</span><span class="p">(</span><span class="n">input_features</span><span class="p">,</span> <span class="n">state_size</span><span class="p">)</span>

<span class="n">forward</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">backward</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100000</span><span class="p">):</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">new_h</span><span class="p">,</span> <span class="n">new_C</span> <span class="o">=</span> <span class="n">rnn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
    <span class="n">forward</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="p">(</span><span class="n">new_h</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span> <span class="n">new_C</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="n">backward</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">'Forward: </span><span class="si">{:.3f}</span><span class="s1"> us | Backward </span><span class="si">{:.3f}</span><span class="s1"> us'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">forward</span> <span class="o">*</span> <span class="mf">1e6</span><span class="o">/</span><span class="mf">1e5</span><span class="p">,</span> <span class="n">backward</span> <span class="o">*</span> <span class="mf">1e6</span><span class="o">/</span><span class="mf">1e5</span><span class="p">))</span>
</pre></div>
</div>
<p>If we run this code with the original LLTM we wrote in pure Python at the start
of this post, we get the following numbers (on my machine):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Forward</span><span class="p">:</span> <span class="mf">506.480</span> <span class="n">us</span> <span class="o">|</span> <span class="n">Backward</span> <span class="mf">444.694</span> <span class="n">us</span>
</pre></div>
</div>
<p>and with our new C++ version:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Forward</span><span class="p">:</span> <span class="mf">349.335</span> <span class="n">us</span> <span class="o">|</span> <span class="n">Backward</span> <span class="mf">443.523</span> <span class="n">us</span>
</pre></div>
</div>
<p>We can already see a significant speedup for the forward function (more than
30%). For the backward function a speedup is visible, albeit not major one. The
backward pass I wrote above was not particularly optimized and could definitely
be improved. Also, PyTorch’s automatic differentiation engine can automatically
parallelize computation graphs, may use a more efficient flow of operations
overall, and is also implemented in C++, so it’s expected to be fast.
Nevertheless, this is a good start.</p>
</div>
<div class="section" id="performance-on-gpu-devices">
<h4>Performance on GPU Devices<a class="headerlink" href="#performance-on-gpu-devices" title="Permalink to this headline">¶</a></h4>
<p>A wonderful fact about PyTorch’s <em>ATen</em> backend is that it abstracts the
computing device you are running on. This means the same code we wrote for CPU
can <em>also</em> run on GPU, and individual operations will correspondingly dispatch
to GPU-optimized implementations. For certain operations like matrix multiply
(like <code class="docutils literal notranslate"><span class="pre">mm</span></code> or <code class="docutils literal notranslate"><span class="pre">addmm</span></code>), this is a big win. Let’s take a look at how much
performance we gain from running our C++ code with CUDA tensors. No changes to
our implementation are required, we simply need to put our tensors in GPU
memory from Python, with either adding <code class="docutils literal notranslate"><span class="pre">device=cuda_device</span></code> argument at
creation time or using <code class="docutils literal notranslate"><span class="pre">.to(cuda_device)</span></code> after creation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>

<span class="k">assert</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span>
<span class="n">cuda_device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">"cuda"</span><span class="p">)</span>  <span class="c1"># device object representing GPU</span>

<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">input_features</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">state_size</span> <span class="o">=</span> <span class="mi">128</span>

<span class="c1"># Note the device=cuda_device arguments here</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">input_features</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">cuda_device</span><span class="p">)</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">state_size</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">cuda_device</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">state_size</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">cuda_device</span><span class="p">)</span>

<span class="n">rnn</span> <span class="o">=</span> <span class="n">LLTM</span><span class="p">(</span><span class="n">input_features</span><span class="p">,</span> <span class="n">state_size</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">cuda_device</span><span class="p">)</span>

<span class="n">forward</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">backward</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100000</span><span class="p">):</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">new_h</span><span class="p">,</span> <span class="n">new_C</span> <span class="o">=</span> <span class="n">rnn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
    <span class="n">forward</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="p">(</span><span class="n">new_h</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span> <span class="n">new_C</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
    <span class="n">backward</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">'Forward: </span><span class="si">{:.3f}</span><span class="s1"> us | Backward </span><span class="si">{:.3f}</span><span class="s1"> us'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">forward</span> <span class="o">*</span> <span class="mf">1e6</span><span class="o">/</span><span class="mf">1e5</span><span class="p">,</span> <span class="n">backward</span> <span class="o">*</span> <span class="mf">1e6</span><span class="o">/</span><span class="mf">1e5</span><span class="p">))</span>
</pre></div>
</div>
<p>Once more comparing our plain PyTorch code with our C++ version, now both
running on CUDA devices, we again see performance gains. For Python/PyTorch:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Forward</span><span class="p">:</span> <span class="mf">187.719</span> <span class="n">us</span> <span class="o">|</span> <span class="n">Backward</span> <span class="mf">410.815</span> <span class="n">us</span>
</pre></div>
</div>
<p>And C++/ATen:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Forward</span><span class="p">:</span> <span class="mf">149.802</span> <span class="n">us</span> <span class="o">|</span> <span class="n">Backward</span> <span class="mf">393.458</span> <span class="n">us</span>
</pre></div>
</div>
<p>That’s a great overall speedup compared to non-CUDA code. However, we can pull
even more performance out of our C++ code by writing custom CUDA kernels, which
we’ll dive into soon. Before that, let’s dicuss another way of building your C++
extensions.</p>
</div>
</div>
<div class="section" id="jit-compiling-extensions">
<h3>JIT Compiling Extensions<a class="headerlink" href="#jit-compiling-extensions" title="Permalink to this headline">¶</a></h3>
<p>Previously, I mentioned there were two ways of building C++ extensions: using
<code class="xref py py-mod docutils literal notranslate"><span class="pre">setuptools</span></code> or just in time (JIT). Having covered the former, let’s
elaborate on the latter. The JIT compilation mechanism provides you with a way
of compiling and loading your extensions on the fly by calling a simple
function in PyTorch’s API called <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.utils.cpp_extension.load()</span></code>. For
the LLTM, this would look as simple as this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">torch.utils.cpp_extension</span> <span class="k">import</span> <span class="n">load</span>

<span class="n">lltm_cpp</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">"lltm_cpp"</span><span class="p">,</span> <span class="n">sources</span><span class="o">=</span><span class="p">[</span><span class="s2">"lltm.cpp"</span><span class="p">])</span>
</pre></div>
</div>
<p>Here, we provide the function with the same information as for
<code class="xref py py-mod docutils literal notranslate"><span class="pre">setuptools</span></code>. In the background, this will do the following:</p>
<ol class="arabic simple">
<li>Create a temporary directory <code class="docutils literal notranslate"><span class="pre">/tmp/torch_extensions/lltm</span></code>,</li>
<li>Emit a <a class="reference external" href="https://ninja-build.org/">Ninja</a> build file into that temporary directory,</li>
<li>Compile your source files into a shared library,</li>
<li>Import this shared library as a Python module.</li>
</ol>
<p>In fact, if you pass <code class="docutils literal notranslate"><span class="pre">verbose=True</span></code> to <code class="xref py py-func docutils literal notranslate"><span class="pre">cpp_extension.load()</span></code>, you will
be informed about the process:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Using</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">torch_extensions</span> <span class="k">as</span> <span class="n">PyTorch</span> <span class="n">extensions</span> <span class="n">root</span><span class="o">...</span>
<span class="n">Emitting</span> <span class="n">ninja</span> <span class="n">build</span> <span class="n">file</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">torch_extensions</span><span class="o">/</span><span class="n">lltm_cpp</span><span class="o">/</span><span class="n">build</span><span class="o">.</span><span class="n">ninja</span><span class="o">...</span>
<span class="n">Building</span> <span class="n">extension</span> <span class="n">module</span> <span class="n">lltm_cpp</span><span class="o">...</span>
<span class="n">Loading</span> <span class="n">extension</span> <span class="n">module</span> <span class="n">lltm_cpp</span><span class="o">...</span>
</pre></div>
</div>
<p>The resulting Python module will be exactly the same as produced by setuptools,
but removes the requirement of having to maintain a separate <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> build
file. If your setup is more complicated and you do need the full power of
<code class="xref py py-mod docutils literal notranslate"><span class="pre">setuptools</span></code>, you <em>can</em> write your own <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> – but in many cases
this JIT technique will do just fine. The first time you run through this line,
it will take some time, as the extension is compiling in the background. Since
we use the Ninja build system to build your sources, re-compilation is
incremental and thus re-loading the extension when you run your Python module a
second time is fast and has low overhead if you didn’t change the extension’s
source files.</p>
</div>
</div>
<div class="section" id="writing-a-mixed-c-cuda-extension">
<h2>Writing a Mixed C++/CUDA extension<a class="headerlink" href="#writing-a-mixed-c-cuda-extension" title="Permalink to this headline">¶</a></h2>
<p>To really take our implementation to the next level, we can hand-write parts of
our forward and backward passes with custom CUDA kernels. For the LLTM, this has
the prospect of being particularly effective, as there are a large number of
pointwise operations in sequence, that can all be fused and parallelized in a
single CUDA kernel. Let’s see how we could write such a CUDA kernel and
integrate it with PyTorch using this extension mechanism.</p>
<p>The general strategy for writing a CUDA extension is to first write a C++ file
which defines the functions that will be called from Python, and binds those
functions to Python with pybind11. Furthermore, this file will also <em>declare</em>
functions that are defined in CUDA (<code class="docutils literal notranslate"><span class="pre">.cu</span></code>) files. The C++ functions will then
do some checks and ultimately forward its calls to the CUDA functions. In the
CUDA files, we write our actual CUDA kernels. The <code class="xref py py-mod docutils literal notranslate"><span class="pre">cpp_extension</span></code> package
will then take care of compiling the C++ sources with a C++ compiler like
<code class="docutils literal notranslate"><span class="pre">gcc</span></code> and the CUDA sources with NVIDIA’s <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> compiler. This ensures that
each compiler takes care of files it knows best to compile. Ultimately, they
will be linked into one shared library that is available to us from Python
code.</p>
<p>We’ll start with the C++ file, which we’ll call <code class="docutils literal notranslate"><span class="pre">lltm_cuda.cpp</span></code>, for example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;torch/extension.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="c1">// CUDA forward declarations</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lltm_cuda_forward</span><span class="p">(</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">input</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">weights</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">bias</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">old_h</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">old_cell</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lltm_cuda_backward</span><span class="p">(</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">grad_h</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">grad_cell</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">new_cell</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">input_gate</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">output_gate</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">candidate_cell</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">X</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">gate_weights</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">weights</span><span class="p">);</span>

<span class="c1">// C++ interface</span>

<span class="cp">#define CHECK_CUDA(x) AT_ASSERTM(x.type().is_cuda(), #x " must be a CUDA tensor")</span>
<span class="cp">#define CHECK_CONTIGUOUS(x) AT_ASSERTM(x.is_contiguous(), #x " must be contiguous")</span>
<span class="cp">#define CHECK_INPUT(x) CHECK_CUDA(x); CHECK_CONTIGUOUS(x)</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lltm_forward</span><span class="p">(</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">input</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">weights</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">bias</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">old_h</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">old_cell</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">weights</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">bias</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">old_h</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">old_cell</span><span class="p">);</span>

  <span class="k">return</span> <span class="nf">lltm_cuda_forward</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">old_h</span><span class="p">,</span> <span class="n">old_cell</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lltm_backward</span><span class="p">(</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">grad_h</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">grad_cell</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">new_cell</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">input_gate</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">output_gate</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">candidate_cell</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">X</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">gate_weights</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">weights</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">grad_h</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">grad_cell</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">input_gate</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">output_gate</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">candidate_cell</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">X</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">gate_weights</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">weights</span><span class="p">);</span>

  <span class="k">return</span> <span class="nf">lltm_cuda_backward</span><span class="p">(</span>
      <span class="n">grad_h</span><span class="p">,</span>
      <span class="n">grad_cell</span><span class="p">,</span>
      <span class="n">new_cell</span><span class="p">,</span>
      <span class="n">input_gate</span><span class="p">,</span>
      <span class="n">output_gate</span><span class="p">,</span>
      <span class="n">candidate_cell</span><span class="p">,</span>
      <span class="n">X</span><span class="p">,</span>
      <span class="n">gate_weights</span><span class="p">,</span>
      <span class="n">weights</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">PYBIND11_MODULE</span><span class="p">(</span><span class="n">TORCH_EXTENSION_NAME</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">"forward"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lltm_forward</span><span class="p">,</span> <span class="s">"LLTM forward (CUDA)"</span><span class="p">);</span>
  <span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">"backward"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lltm_backward</span><span class="p">,</span> <span class="s">"LLTM backward (CUDA)"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As you can see, it is largely boilerplate, checks and forwarding to functions
that we’ll define in the CUDA file. We’ll name this file
<code class="docutils literal notranslate"><span class="pre">lltm_cuda_kernel.cu</span></code> (note the <code class="docutils literal notranslate"><span class="pre">.cu</span></code> extension!). NVCC can reasonably
compile C++11, thus we still have ATen and the C++ standard library available
to us (but not <code class="docutils literal notranslate"><span class="pre">torch.h</span></code>). Note that <code class="xref py py-mod docutils literal notranslate"><span class="pre">setuptools</span></code> cannot handle files
with the same name but different extensions, so if you use the <code class="docutils literal notranslate"><span class="pre">setup.py</span></code>
method instead of the JIT method, you must give your CUDA file a different name
than your C++ file (for the JIT method, <code class="docutils literal notranslate"><span class="pre">lltm.cpp</span></code> and <code class="docutils literal notranslate"><span class="pre">lltm.cu</span></code> would work
fine). Let’s take a small peek at what this file will look like:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;torch/extension.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;cuda.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cuda_runtime.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">scalar_t</span><span class="o">&gt;</span>
<span class="n">__device__</span> <span class="n">__forceinline__</span> <span class="n">scalar_t</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">scalar_t</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we see the headers I just described, as well as the fact that we are using
CUDA-specific declarations like <code class="docutils literal notranslate"><span class="pre">__device__</span></code> and <code class="docutils literal notranslate"><span class="pre">__forceinline__</span></code> and
functions like <code class="docutils literal notranslate"><span class="pre">exp</span></code>. Let’s continue with a few more helper functions that
we’ll need:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">scalar_t</span><span class="o">&gt;</span>
<span class="n">__device__</span> <span class="n">__forceinline__</span> <span class="n">scalar_t</span> <span class="n">d_sigmoid</span><span class="p">(</span><span class="n">scalar_t</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">scalar_t</span><span class="o">&gt;</span>
<span class="n">__device__</span> <span class="n">__forceinline__</span> <span class="n">scalar_t</span> <span class="n">d_tanh</span><span class="p">(</span><span class="n">scalar_t</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tanh</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">scalar_t</span><span class="o">&gt;</span>
<span class="n">__device__</span> <span class="n">__forceinline__</span> <span class="n">scalar_t</span> <span class="n">elu</span><span class="p">(</span><span class="n">scalar_t</span> <span class="n">z</span><span class="p">,</span> <span class="n">scalar_t</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">fmax</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">fmin</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">scalar_t</span><span class="o">&gt;</span>
<span class="n">__device__</span> <span class="n">__forceinline__</span> <span class="n">scalar_t</span> <span class="n">d_elu</span><span class="p">(</span><span class="n">scalar_t</span> <span class="n">z</span><span class="p">,</span> <span class="n">scalar_t</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">d_relu</span> <span class="o">=</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="o">?</span> <span class="mf">0.0</span> <span class="o">:</span> <span class="mf">1.0</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">d_relu</span> <span class="o">+</span> <span class="p">(((</span><span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">e</span><span class="p">)</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To now actually implement a function, we’ll again need two things: one function
that performs operations we don’t wish to explicitly write by hand and calls
into CUDA kernels, and then the actual CUDA kernel for the parts we want to
speed up. For the forward pass, the first function should look like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lltm_cuda_forward</span><span class="p">(</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">input</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">weights</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">bias</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">old_h</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">old_cell</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">cat</span><span class="p">({</span><span class="n">old_h</span><span class="p">,</span> <span class="n">input</span><span class="p">},</span> <span class="cm">/*dim=*/</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">gates</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">addmm</span><span class="p">(</span><span class="n">bias</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">weights</span><span class="p">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>

  <span class="k">const</span> <span class="k">auto</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="n">old_cell</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">state_size</span> <span class="o">=</span> <span class="n">old_cell</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">new_h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">old_cell</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">new_cell</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">old_cell</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">input_gate</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">old_cell</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">output_gate</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">old_cell</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">candidate_cell</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">old_cell</span><span class="p">);</span>

  <span class="k">const</span> <span class="kt">int</span> <span class="n">threads</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">dim3</span> <span class="nf">blocks</span><span class="p">((</span><span class="n">state_size</span> <span class="o">+</span> <span class="n">threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">threads</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">);</span>

  <span class="n">AT_DISPATCH_FLOATING_TYPES</span><span class="p">(</span><span class="n">gates</span><span class="p">.</span><span class="n">type</span><span class="p">(),</span> <span class="s">"lltm_forward_cuda"</span><span class="p">,</span> <span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
    <span class="n">lltm_cuda_forward_kernel</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span> <span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span>
        <span class="n">gates</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">old_cell</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">new_h</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">new_cell</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">input_gate</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">output_gate</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">candidate_cell</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">state_size</span><span class="p">);</span>
  <span class="p">}));</span>

  <span class="k">return</span> <span class="p">{</span><span class="n">new_h</span><span class="p">,</span> <span class="n">new_cell</span><span class="p">,</span> <span class="n">input_gate</span><span class="p">,</span> <span class="n">output_gate</span><span class="p">,</span> <span class="n">candidate_cell</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">gates</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The main point of interest here is the <code class="docutils literal notranslate"><span class="pre">AT_DISPATCH_FLOATING_TYPES</span></code> macro and
the kernel launch (indicated by the <code class="docutils literal notranslate"><span class="pre">&lt;&lt;&lt;...&gt;&gt;&gt;</span></code>). While ATen abstracts away
the device and datatype of the tensors we deal with, a tensor will, at runtime,
still be backed by memory of a concrete type on a concrete device. As such, we
need a way of determining at runtime what type a tensor is and then selectively
call functions with the corresponding correct type signature. Done manually,
this would (conceptually) look something like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">switch</span> <span class="p">(</span><span class="n">tensor</span><span class="p">.</span><span class="n">type</span><span class="p">().</span><span class="n">scalarType</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">torch</span><span class="o">::</span><span class="n">ScalarType</span><span class="o">::</span><span class="nl">Double</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tensor</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="k">case</span> <span class="n">torch</span><span class="o">::</span><span class="n">ScalarType</span><span class="o">::</span><span class="nl">Float</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tensor</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The purpose of <code class="docutils literal notranslate"><span class="pre">AT_DISPATCH_FLOATING_TYPES</span></code> is to take care of this dispatch
for us. It takes a type (<code class="docutils literal notranslate"><span class="pre">gates.type()</span></code> in our case), a name (for error
messages) and a lambda function. Inside this lambda function, the type alias
<code class="docutils literal notranslate"><span class="pre">scalar_t</span></code> is available and is defined as the type that the tensor actually
is at runtime in that context. As such, if we have a template function (which
our CUDA kernel will be), we can instantiate it with this <code class="docutils literal notranslate"><span class="pre">scalar_t</span></code> alias,
and the correct function will be called. In this case, we also want to retrieve
the data pointers of the tensors as pointers of that <code class="docutils literal notranslate"><span class="pre">scalar_t</span></code> type. If you
wanted to dispatch over all types and not just floating point types (<code class="docutils literal notranslate"><span class="pre">Float</span></code>
and <code class="docutils literal notranslate"><span class="pre">Double</span></code>), you can use <code class="docutils literal notranslate"><span class="pre">AT_DISPATCH_ALL_TYPES</span></code>.</p>
<p>Note that we perform some operations with plain ATen. These operations will
still run on the GPU, but using ATen’s default implementations. This makes
sense, because ATen will use highly optimized routines for things like matrix
multiplies (e.g. <code class="docutils literal notranslate"><span class="pre">addmm</span></code>) or convolutions which would be much harder to
implement and improve ourselves.</p>
<p>As for the kernel launch itself, we are here specifying that each CUDA block
will have 1024 threads, and that the entire GPU grid is split into as many
blocks of <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">x</span> <span class="pre">1024</span></code> threads as are required to fill our matrices with one
thread per component. For example, if our state size was 2048 and our batch
size 4, we’d launch a total of <code class="docutils literal notranslate"><span class="pre">4</span> <span class="pre">x</span> <span class="pre">2</span> <span class="pre">=</span> <span class="pre">8</span></code> blocks with each 1024 threads. If
you’ve never heard of CUDA “blocks” or “grids” before, an <a class="reference external" href="https://devblogs.nvidia.com/even-easier-introduction-cuda">introductory read
about CUDA</a> may
help.</p>
<p>The actual CUDA kernel is fairly simple (if you’ve ever programmed GPUs before):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">scalar_t</span><span class="o">&gt;</span>
<span class="n">__global__</span> <span class="kt">void</span> <span class="n">lltm_cuda_forward_kernel</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">gates</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">old_cell</span><span class="p">,</span>
    <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">new_h</span><span class="p">,</span>
    <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">new_cell</span><span class="p">,</span>
    <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">input_gate</span><span class="p">,</span>
    <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">output_gate</span><span class="p">,</span>
    <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">candidate_cell</span><span class="p">,</span>
    <span class="kt">size_t</span> <span class="n">state_size</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">column</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">state_size</span> <span class="o">+</span> <span class="n">column</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">gates_row</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">state_size</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">column</span> <span class="o">&lt;</span> <span class="n">state_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">input_gate</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="n">gates_row</span> <span class="o">+</span> <span class="n">column</span><span class="p">]);</span>
    <span class="n">output_gate</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="n">gates_row</span> <span class="o">+</span> <span class="n">state_size</span> <span class="o">+</span> <span class="n">column</span><span class="p">]);</span>
    <span class="n">candidate_cell</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">elu</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="n">gates_row</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">state_size</span> <span class="o">+</span> <span class="n">column</span><span class="p">]);</span>
    <span class="n">new_cell</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span>
        <span class="n">old_cell</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="n">candidate_cell</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">*</span> <span class="n">input_gate</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="n">new_h</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">tanh</span><span class="p">(</span><span class="n">new_cell</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="o">*</span> <span class="n">output_gate</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>What’s primarily interesting here is that we are able to compute all of these
pointwise operations entirely in parallel for each individual component in our
gate matrices. If you imagine having to do this with a giant <code class="docutils literal notranslate"><span class="pre">for</span></code> loop over
a million elements in serial, you can see why this would be much faster.</p>
<div class="section" id="using-accessors">
<h3>Using accessors<a class="headerlink" href="#using-accessors" title="Permalink to this headline">¶</a></h3>
<p>You can see in the CUDA kernel that we work directly on pointers with the right
type. Indeed, working directly with high level type agnostic tensors inside cuda
kernels would be very inefficient.</p>
<p>However, this comes at a cost of ease of use and readibility, especially for
highly dimensional data. In our example, we know for example that the contiguous
<code class="docutils literal notranslate"><span class="pre">gates</span></code> tensor has 3 dimensions:</p>
<ol class="arabic simple">
<li>batch, size of <code class="docutils literal notranslate"><span class="pre">batch_size</span></code> and stride of <code class="docutils literal notranslate"><span class="pre">3*state_size</span></code></li>
<li>row, size of <code class="docutils literal notranslate"><span class="pre">3</span></code> and stride of <code class="docutils literal notranslate"><span class="pre">state_size</span></code></li>
<li>index, size  of <code class="docutils literal notranslate"><span class="pre">state_size</span></code> and stride of <code class="docutils literal notranslate"><span class="pre">1</span></code></li>
</ol>
<p>How can we access the element <code class="docutils literal notranslate"><span class="pre">gates[n][row][column]</span></code> inside the kernel then?
It turns out that you need the strides to access your element with some simple
arithmetic.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">gates</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">()[</span><span class="n">n</span><span class="o">*</span><span class="mi">3</span><span class="o">*</span><span class="n">state_size</span> <span class="o">+</span> <span class="n">row</span><span class="o">*</span><span class="n">state_size</span> <span class="o">+</span> <span class="n">column</span><span class="p">]</span>
</pre></div>
</div>
<p>In addition to being verbose, this expression needs stride to be explicitely
known, and thus passed to the kernel function within its arguments. You can see
that in the case of kernel functions accepting multiple tensors with different
sizes you will end up with a very long list of arguments.</p>
<p>Fortunately for us, ATen provides accessors that are created with a single
dynamic check that a Tensor is the type and number of dimensions.
Accessors then expose an API for accessing the Tensor elements efficiently
without having to convert to a single pointer:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">rand</span><span class="p">({</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">});</span>

<span class="c1">// assert foo is 2-dimensional and holds floats.</span>
<span class="k">auto</span> <span class="n">foo_a</span> <span class="o">=</span> <span class="n">foo</span><span class="p">.</span><span class="n">accessor</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">();</span>
<span class="kt">float</span> <span class="n">trace</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">foo_a</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// use the accessor foo_a to get tensor data.</span>
  <span class="n">trace</span> <span class="o">+=</span> <span class="n">foo_a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Accessor objects have a relatively high level interface, with <code class="docutils literal notranslate"><span class="pre">.size()</span></code> and
<code class="docutils literal notranslate"><span class="pre">.stride()</span></code> methods and multi-dimensional indexing. The <code class="docutils literal notranslate"><span class="pre">.accessor&lt;&gt;</span></code>
interface is designed to access data efficiently on cpu tensor. The equivalent
for cuda tensors is the <code class="docutils literal notranslate"><span class="pre">packed_accessor&lt;&gt;</span></code>, which produces a Packed Accessor.</p>
<p>The fundamental difference with Accessor is that a Packed Accessor copies size
and stride data inside of its structure instead of pointing to it. It allows us
to pass it to a CUDA kernel function and use its interface inside it.</p>
<p>We can design a function that takes Packed Accessors instead of pointers.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span> <span class="kt">void</span> <span class="n">lltm_cuda_forward_kernel</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">gates</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">old_cell</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">new_h</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">new_cell</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">input_gate</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">output_gate</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">candidate_cell</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s decompose the template used here. the first two arguments <code class="docutils literal notranslate"><span class="pre">scalar_t</span></code> and
<code class="docutils literal notranslate"><span class="pre">2</span></code> are the same as regular Accessor. The argument
<code class="docutils literal notranslate"><span class="pre">torch::RestrictPtrTraits</span></code> indicates that the <code class="docutils literal notranslate"><span class="pre">__restrict__</span></code> keyword must be
used. Finally, the argument <code class="docutils literal notranslate"><span class="pre">size_t</span></code> indicates that sizes and strides must be
stored in a <code class="docutils literal notranslate"><span class="pre">size_t</span></code> integer. This is important as by default <code class="docutils literal notranslate"><span class="pre">int64_t</span></code> is
used and can make the kernel slower.</p>
<p>The function declaration becomes</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">scalar_t</span><span class="o">&gt;</span>
<span class="n">__global__</span> <span class="kt">void</span> <span class="n">lltm_cuda_forward_kernel</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">gates</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">old_cell</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">new_h</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">new_cell</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">input_gate</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">output_gate</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">candidate_cell</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//batch index</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
  <span class="c1">// column index</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">gates</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">2</span><span class="p">)){</span>
    <span class="n">input_gate</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">c</span><span class="p">]);</span>
    <span class="n">output_gate</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">]);</span>
    <span class="n">candidate_cell</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">elu</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="n">c</span><span class="p">]);</span>
    <span class="n">new_cell</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span>
        <span class="n">old_cell</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="n">candidate_cell</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">*</span> <span class="n">input_gate</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">];</span>
    <span class="n">new_h</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">tanh</span><span class="p">(</span><span class="n">new_cell</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">])</span> <span class="o">*</span> <span class="n">output_gate</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The implementation is much more readable! This function is then called by
creating Packed Accessors with the <code class="docutils literal notranslate"><span class="pre">.packed_accessor&lt;&gt;</span></code> method within the
host function.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lltm_cuda_forward</span><span class="p">(</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">input</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">weights</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">bias</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">old_h</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">old_cell</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">cat</span><span class="p">({</span><span class="n">old_h</span><span class="p">,</span> <span class="n">input</span><span class="p">},</span> <span class="cm">/*dim=*/</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">gate_weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">addmm</span><span class="p">(</span><span class="n">bias</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">weights</span><span class="p">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>

  <span class="k">const</span> <span class="k">auto</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="n">old_cell</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">state_size</span> <span class="o">=</span> <span class="n">old_cell</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">gates</span> <span class="o">=</span> <span class="n">gate_weights</span><span class="p">.</span><span class="n">reshape</span><span class="p">({</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">state_size</span><span class="p">});</span>
  <span class="k">auto</span> <span class="n">new_h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">old_cell</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">new_cell</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">old_cell</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">input_gate</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">old_cell</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">output_gate</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">old_cell</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">candidate_cell</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">old_cell</span><span class="p">);</span>

  <span class="k">const</span> <span class="kt">int</span> <span class="n">threads</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">dim3</span> <span class="nf">blocks</span><span class="p">((</span><span class="n">state_size</span> <span class="o">+</span> <span class="n">threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">threads</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">);</span>

  <span class="n">AT_DISPATCH_FLOATING_TYPES</span><span class="p">(</span><span class="n">gates</span><span class="p">.</span><span class="n">type</span><span class="p">(),</span> <span class="s">"lltm_forward_cuda"</span><span class="p">,</span> <span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
    <span class="n">lltm_cuda_forward_kernel</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span> <span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span>
        <span class="n">gates</span><span class="p">.</span><span class="n">packed_accessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">old_cell</span><span class="p">.</span><span class="n">packed_accessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">new_h</span><span class="p">.</span><span class="n">packed_accessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">new_cell</span><span class="p">.</span><span class="n">packed_accessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">input_gate</span><span class="p">.</span><span class="n">packed_accessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">output_gate</span><span class="p">.</span><span class="n">packed_accessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">candidate_cell</span><span class="p">.</span><span class="n">packed_accessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="p">}));</span>

  <span class="k">return</span> <span class="p">{</span><span class="n">new_h</span><span class="p">,</span> <span class="n">new_cell</span><span class="p">,</span> <span class="n">input_gate</span><span class="p">,</span> <span class="n">output_gate</span><span class="p">,</span> <span class="n">candidate_cell</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">gates</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The backwards pass follows much the same pattern and I won’t elaborate further
on it:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">scalar_t</span><span class="o">&gt;</span>
<span class="n">__global__</span> <span class="kt">void</span> <span class="n">lltm_cuda_backward_kernel</span><span class="p">(</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">d_old_cell</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">d_gates</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">grad_h</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">grad_cell</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">new_cell</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">input_gate</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">output_gate</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">candidate_cell</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">torch</span><span class="o">::</span><span class="n">PackedTensorAccessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">gate_weights</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//batch index</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
  <span class="c1">// column index</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">d_gates</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">2</span><span class="p">)){</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">d_output_gate</span> <span class="o">=</span> <span class="n">tanh</span><span class="p">(</span><span class="n">new_cell</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">])</span> <span class="o">*</span> <span class="n">grad_h</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">];</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">d_tanh_new_cell</span> <span class="o">=</span> <span class="n">output_gate</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">*</span> <span class="n">grad_h</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">];</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">d_new_cell</span> <span class="o">=</span>
        <span class="n">d_tanh</span><span class="p">(</span><span class="n">new_cell</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">])</span> <span class="o">*</span> <span class="n">d_tanh_new_cell</span> <span class="o">+</span> <span class="n">grad_cell</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">];</span>


    <span class="n">d_old_cell</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_new_cell</span><span class="p">;</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">d_candidate_cell</span> <span class="o">=</span> <span class="n">input_gate</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">*</span> <span class="n">d_new_cell</span><span class="p">;</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">d_input_gate</span> <span class="o">=</span> <span class="n">candidate_cell</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">*</span> <span class="n">d_new_cell</span><span class="p">;</span>

    <span class="n">d_gates</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span>
        <span class="n">d_input_gate</span> <span class="o">*</span> <span class="n">d_sigmoid</span><span class="p">(</span><span class="n">gate_weights</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">c</span><span class="p">]);</span>
    <span class="n">d_gates</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span>
        <span class="n">d_output_gate</span> <span class="o">*</span> <span class="n">d_sigmoid</span><span class="p">(</span><span class="n">gate_weights</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">]);</span>
    <span class="n">d_gates</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span>
        <span class="n">d_candidate_cell</span> <span class="o">*</span> <span class="n">d_elu</span><span class="p">(</span><span class="n">gate_weights</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="n">c</span><span class="p">]);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lltm_cuda_backward</span><span class="p">(</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">grad_h</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">grad_cell</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">new_cell</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">input_gate</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">output_gate</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">candidate_cell</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">X</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">gates</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">weights</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">d_old_cell</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">new_cell</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">d_gates</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">gates</span><span class="p">);</span>

  <span class="k">const</span> <span class="k">auto</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="n">new_cell</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">state_size</span> <span class="o">=</span> <span class="n">new_cell</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="k">const</span> <span class="kt">int</span> <span class="n">threads</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">dim3</span> <span class="nf">blocks</span><span class="p">((</span><span class="n">state_size</span> <span class="o">+</span> <span class="n">threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">threads</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">);</span>

  <span class="n">AT_DISPATCH_FLOATING_TYPES</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">type</span><span class="p">(),</span> <span class="s">"lltm_forward_cuda"</span><span class="p">,</span> <span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
    <span class="n">lltm_cuda_backward_kernel</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span> <span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span>
        <span class="n">d_old_cell</span><span class="p">.</span><span class="n">packed_accessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">d_gates</span><span class="p">.</span><span class="n">packed_accessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">grad_h</span><span class="p">.</span><span class="n">packed_accessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">grad_cell</span><span class="p">.</span><span class="n">packed_accessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">new_cell</span><span class="p">.</span><span class="n">packed_accessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">input_gate</span><span class="p">.</span><span class="n">packed_accessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">output_gate</span><span class="p">.</span><span class="n">packed_accessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">candidate_cell</span><span class="p">.</span><span class="n">packed_accessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">gates</span><span class="p">.</span><span class="n">packed_accessor</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">torch</span><span class="o">::</span><span class="n">RestrictPtrTraits</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="p">}));</span>

  <span class="k">auto</span> <span class="n">d_gate_weights</span> <span class="o">=</span> <span class="n">d_gates</span><span class="p">.</span><span class="n">reshape</span><span class="p">({</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">state_size</span><span class="p">});</span>
  <span class="k">auto</span> <span class="n">d_weights</span> <span class="o">=</span> <span class="n">d_gate_weights</span><span class="p">.</span><span class="n">t</span><span class="p">().</span><span class="n">mm</span><span class="p">(</span><span class="n">X</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">d_bias</span> <span class="o">=</span> <span class="n">d_gate_weights</span><span class="p">.</span><span class="n">sum</span><span class="p">(</span><span class="cm">/*dim=*/</span><span class="mi">0</span><span class="p">,</span> <span class="cm">/*keepdim=*/</span><span class="nb">true</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">d_X</span> <span class="o">=</span> <span class="n">d_gate_weights</span><span class="p">.</span><span class="n">mm</span><span class="p">(</span><span class="n">weights</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">d_old_h</span> <span class="o">=</span> <span class="n">d_X</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="cm">/*dim=*/</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">state_size</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">d_input</span> <span class="o">=</span> <span class="n">d_X</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="cm">/*dim=*/</span><span class="mi">1</span><span class="p">,</span> <span class="n">state_size</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">{</span><span class="n">d_old_h</span><span class="p">,</span> <span class="n">d_input</span><span class="p">,</span> <span class="n">d_weights</span><span class="p">,</span> <span class="n">d_bias</span><span class="p">,</span> <span class="n">d_old_cell</span><span class="p">,</span> <span class="n">d_gates</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="integrating-a-c-cuda-operation-with-pytorch">
<h3>Integrating a C++/CUDA Operation with PyTorch<a class="headerlink" href="#integrating-a-c-cuda-operation-with-pytorch" title="Permalink to this headline">¶</a></h3>
<p>Integration of our CUDA-enabled op with PyTorch is again very straightforward.
If you want to write a <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script, it could look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="k">import</span> <span class="n">setup</span>
<span class="kn">from</span> <span class="nn">torch.utils.cpp_extension</span> <span class="k">import</span> <span class="n">BuildExtension</span><span class="p">,</span> <span class="n">CUDAExtension</span>

<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">'lltm'</span><span class="p">,</span>
    <span class="n">ext_modules</span><span class="o">=</span><span class="p">[</span>
        <span class="n">CUDAExtension</span><span class="p">(</span><span class="s1">'lltm_cuda'</span><span class="p">,</span> <span class="p">[</span>
            <span class="s1">'lltm_cuda.cpp'</span><span class="p">,</span>
            <span class="s1">'lltm_cuda_kernel.cu'</span><span class="p">,</span>
        <span class="p">])</span>
    <span class="p">],</span>
    <span class="n">cmdclass</span><span class="o">=</span><span class="p">{</span>
        <span class="s1">'build_ext'</span><span class="p">:</span> <span class="n">BuildExtension</span>
    <span class="p">})</span>
</pre></div>
</div>
<p>Instead of <code class="xref py py-func docutils literal notranslate"><span class="pre">CppExtension()</span></code>, we now use <code class="xref py py-func docutils literal notranslate"><span class="pre">CUDAExtension()</span></code>. We can just
specify the <code class="docutils literal notranslate"><span class="pre">.cu</span></code> file along with the <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> files – the library takes
care of all the hassle this entails for you. The JIT mechanism is even
simpler:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">torch.utils.cpp_extension</span> <span class="k">import</span> <span class="n">load</span>

<span class="n">lltm</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">'lltm'</span><span class="p">,</span> <span class="n">sources</span><span class="o">=</span><span class="p">[</span><span class="s1">'lltm_cuda.cpp'</span><span class="p">,</span> <span class="s1">'lltm_cuda_kernel.cu'</span><span class="p">])</span>
</pre></div>
</div>
<div class="section" id="id2">
<h4>Performance Comparison<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Our hope was that parallelizing and fusing the pointwise operations of our code
with CUDA would improve the performance of our LLTM. Let’s see if that holds
true. We can run the code I listed earlier to run a benchmark. Our fastest
version earlier was the CUDA-based C++ code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Forward</span><span class="p">:</span> <span class="mf">149.802</span> <span class="n">us</span> <span class="o">|</span> <span class="n">Backward</span> <span class="mf">393.458</span> <span class="n">us</span>
</pre></div>
</div>
<p>And now with our custom CUDA kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Forward</span><span class="p">:</span> <span class="mf">129.431</span> <span class="n">us</span> <span class="o">|</span> <span class="n">Backward</span> <span class="mf">304.641</span> <span class="n">us</span>
</pre></div>
</div>
<p>More performance increases!</p>
</div>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>You should now be equipped with a good overview of PyTorch’s C++ extension
mechanism as well as a motivation for using them. You can find the code
examples displayed in this note <a class="reference external" href="https://github.com/pytorch/extension-cpp">here</a>. If you have questions, please use
<a class="reference external" href="https://discuss.pytorch.org">the forums</a>. Also be sure to check our <a class="reference external" href="https://pytorch.org/cppdocs/notes/faq.html">FAQ</a> in case you run into any issues.</p>
</div>
</div>
</article>
</div>
<footer>
<div aria-label="footer navigation" class="rst-footer-buttons" role="navigation">
<a accesskey="n" class="btn btn-neutral float-right" href="torch_script_custom_ops.html" rel="next" title="Extending TorchScript with Custom C++ Operators">Next <img class="next-page" src="../_static/images/chevron-right-orange.svg"/></a>
<a accesskey="p" class="btn btn-neutral" href="numpy_extensions_tutorial.html" rel="prev" title="Creating Extensions Using numpy and scipy"><img class="previous-page" src="../_static/images/chevron-right-orange.svg"/> Previous</a>
</div>
<hr/>
<div role="contentinfo">
<p>
        © Copyright 2017, PyTorch.

    </p>
</div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
</div>
</div>
<div class="pytorch-content-right" id="pytorch-content-right">
<div class="pytorch-right-menu" id="pytorch-right-menu">
<div class="pytorch-side-scroll" id="pytorch-side-scroll-right">
<ul>
<li><a class="reference internal" href="#">Custom C++ and CUDA Extensions</a><ul>
<li><a class="reference internal" href="#motivation-and-example">Motivation and Example</a></li>
<li><a class="reference internal" href="#writing-a-c-extension">Writing a C++ Extension</a><ul>
<li><a class="reference internal" href="#building-with-setuptools">Building with <code class="docutils literal notranslate"><span class="pre">setuptools</span></code></a></li>
<li><a class="reference internal" href="#writing-the-c-op">Writing the C++ Op</a><ul>
<li><a class="reference internal" href="#forward-pass">Forward Pass</a></li>
<li><a class="reference internal" href="#backward-pass">Backward Pass</a></li>
</ul>
</li>
<li><a class="reference internal" href="#binding-to-python">Binding to Python</a></li>
<li><a class="reference internal" href="#using-your-extension">Using Your Extension</a><ul>
<li><a class="reference internal" href="#performance-comparison">Performance Comparison</a></li>
<li><a class="reference internal" href="#performance-on-gpu-devices">Performance on GPU Devices</a></li>
</ul>
</li>
<li><a class="reference internal" href="#jit-compiling-extensions">JIT Compiling Extensions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#writing-a-mixed-c-cuda-extension">Writing a Mixed C++/CUDA extension</a><ul>
<li><a class="reference internal" href="#using-accessors">Using accessors</a></li>
<li><a class="reference internal" href="#integrating-a-c-cuda-operation-with-pytorch">Integrating a C++/CUDA Operation with PyTorch</a><ul>
<li><a class="reference internal" href="#id2">Performance Comparison</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</section>
</div>
<script type="text/javascript">
           var DOCUMENTATION_OPTIONS = {
               URL_ROOT:'../',
               VERSION:'1.0.0',
               LANGUAGE:'None',
               COLLAPSE_INDEX:false,
               FILE_SUFFIX:'.html',
               HAS_SOURCE:  true,
               SOURCELINK_SUFFIX: '.txt'
           };
       </script>
<script src="../_static/jquery.js" type="text/javascript"></script>
<script src="../_static/underscore.js" type="text/javascript"></script>
<script src="../_static/doctools.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<script src="../_static/js/vendor/popper.min.js" type="text/javascript"></script>
<script src="../_static/js/vendor/bootstrap.min.js" type="text/javascript"></script>
<script src="../_static/js/theme.js" type="text/javascript"></script>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-90545585-2', 'auto');
  ga('send', 'pageview');

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-117752657-2"></script>
<script>

  window.dataLayer = window.dataLayer || [];

  function gtag(){dataLayer.push(arguments);}

  gtag('js', new Date());
  gtag('config', 'UA-117752657-2');

</script>
<script>
  !function(f,b,e,v,n,t,s)
  {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
  n.callMethod.apply(n,arguments):n.queue.push(arguments)};
  if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
  n.queue=[];t=b.createElement(e);t.async=!0;
  t.src=v;s=b.getElementsByTagName(e)[0];
  s.parentNode.insertBefore(t,s)}(window,document,'script',
  'https://connect.facebook.net/en_US/fbevents.js');
  fbq('init', '243028289693773');
  fbq('track', 'PageView');

  $("[data-behavior='call-to-action-event']").on('click', function(){
    fbq('trackCustom', "Download", {
      tutorialTitle: $('h1:first').text(),
      downloadLink: this.href,
      tutorialLink: window.location.href,
      downloadTitle: $(this).attr("data-response")
    });
    ga('send', {
      hitType: 'event',
      eventCategory: 'Download',
      eventAction: 'click',
      eventLabel: $(this).attr("data-response")
    });
   });

   $("[data-behavior='was-this-helpful-event']").on('click', function(){
    $(".helpful-question").hide();
    $(".was-helpful-thank-you").show();
    fbq('trackCustom', "Was this Helpful?", {
      tutorialLink: window.location.href,
      tutorialTitle: $('h1:first').text(),
      helpful: $(this).attr("data-response")
    });
    ga('send', {
      hitType: 'event',
      eventCategory: 'Was this Helpful?',
      eventAction: 'click',
      eventLabel: $(this).attr("data-response")
    });
   });

   if (location.pathname == "/") {
     $(".helpful-container").hide();
     $(".hr-bottom").hide();
   }
</script>
<noscript>
<img height="1" src="https://www.facebook.com/tr?id=243028289693773&amp;ev=PageView
  &amp;noscript=1" width="1">
</img></noscript>
<img alt="" height="1" src="https://www.googleadservices.com/pagead/conversion/795629140/?label=txkmCPmdtosBENSssfsC&amp;guid=ON&amp;script=0" style="border-style:none;" width="1">
<!-- Begin Footer -->
<div class="container-fluid docs-tutorials-resources" id="docs-tutorials-resources">
<div class="container">
<div class="row">
<div class="col-md-4 text-center">
<h2>Docs</h2>
<p>Access comprehensive developer documentation for PyTorch</p>
<a class="with-right-arrow" href="https://pytorch.org/docs/stable/index.html">View Docs</a>
</div>
<div class="col-md-4 text-center">
<h2>Tutorials</h2>
<p>Get in-depth tutorials for beginners and advanced developers</p>
<a class="with-right-arrow" href="https://pytorch.org/tutorials">View Tutorials</a>
</div>
<div class="col-md-4 text-center">
<h2>Resources</h2>
<p>Find development resources and get your questions answered</p>
<a class="with-right-arrow" href="https://pytorch.org/resources">View Resources</a>
</div>
</div>
</div>
</div>
<footer class="site-footer">
<div class="container footer-container">
<div class="footer-logo-wrapper">
<a class="footer-logo" href="https://pytorch.org/"></a>
</div>
<div class="footer-links-wrapper">
<div class="footer-links-col">
<ul>
<li class="list-title"><a href="https://pytorch.org/">PyTorch</a></li>
<li><a href="https://pytorch.org/get-started">Get Started</a></li>
<li><a href="https://pytorch.org/features">Features</a></li>
<li><a href="https://pytorch.org/ecosystem">Ecosystem</a></li>
<li><a href="https://pytorch.org/blog/">Blog</a></li>
<li><a href="https://pytorch.org/resources">Resources</a></li>
</ul>
</div>
<div class="footer-links-col">
<ul>
<li class="list-title"><a href="https://pytorch.org/support">Support</a></li>
<li><a href="https://pytorch.org/tutorials">Tutorials</a></li>
<li><a href="https://pytorch.org/docs/stable/index.html">Docs</a></li>
<li><a href="https://discuss.pytorch.org" target="_blank">Discuss</a></li>
<li><a href="https://github.com/pytorch/pytorch/issues" target="_blank">Github Issues</a></li>
<li><a href="https://pytorch.slack.com" target="_blank">Slack</a></li>
<li><a href="https://github.com/pytorch/pytorch/blob/master/CONTRIBUTING.md" target="_blank">Contributing</a></li>
</ul>
</div>
<div class="footer-links-col follow-us-col">
<ul>
<li class="list-title">Follow Us</li>
<li>
<div id="mc_embed_signup">
<form action="https://twitter.us14.list-manage.com/subscribe/post?u=75419c71fe0a935e53dfa4a3f&amp;id=91d0dccd39" class="email-subscribe-form validate" id="mc-embedded-subscribe-form" method="post" name="mc-embedded-subscribe-form" novalidate="" target="_blank">
<div class="email-subscribe-form-fields-wrapper" id="mc_embed_signup_scroll">
<div class="mc-field-group">
<label for="mce-EMAIL" style="display:none;">Email Address</label>
<input class="required email" id="mce-EMAIL" name="EMAIL" placeholder="Email Address" type="email" value=""/>
</div>
<div class="clear" id="mce-responses">
<div class="response" id="mce-error-response" style="display:none"></div>
<div class="response" id="mce-success-response" style="display:none"></div>
</div> <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
<div aria-hidden="true" style="position: absolute; left: -5000px;"><input name="b_75419c71fe0a935e53dfa4a3f_91d0dccd39" tabindex="-1" type="text" value=""/></div>
<div class="clear">
<input class="button email-subscribe-button" id="mc-embedded-subscribe" name="subscribe" type="submit" value=""/>
</div>
</div>
</form>
</div>
</li>
</ul>
<div class="footer-social-icons">
<a class="facebook" href="https://www.facebook.com/pytorch" target="_blank"></a>
<a class="twitter" href="https://twitter.com/pytorch" target="_blank"></a>
</div>
</div>
</div>
</div>
</footer>
<!-- End Footer -->
<!-- Begin Mobile Menu -->
<div class="mobile-main-menu">
<div class="container-fluid">
<div class="container">
<div class="mobile-main-menu-header-container">
<a aria-label="PyTorch" class="header-logo" href="https://pytorch.org/"></a>
<a class="main-menu-close-button" data-behavior="close-mobile-menu" href="#"></a>
</div>
</div>
</div>
<div class="mobile-main-menu-links-container">
<div class="main-menu">
<ul>
<li>
<a href="#">Get Started</a>
</li>
<li>
<a href="#">Features</a>
</li>
<li>
<a href="#">Ecosystem</a>
</li>
<li>
<a href="https://pytorch.org/blog/">Blog</a>
</li>
<li class="active">
<a href="https://pytorch.org/tutorials">Tutorials</a>
</li>
<li>
<a href="https://pytorch.org/docs/stable/index.html">Docs</a>
</li>
<li>
<a href="https://pytorch.org/resources">Resources</a>
</li>
<li>
<a href="https://github.com/pytorch/pytorch">Github</a>
</li>
</ul>
</div>
</div>
</div>
<!-- End Mobile Menu -->
<script src="../_static/js/vendor/anchor.min.js" type="text/javascript"></script>
<script type="text/javascript">
    $(document).ready(function() {
      mobileMenu.bind();
      mobileTOC.bind();
      pytorchAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.pytorch-article a span.pre").each(function(e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</img></body>
</html>